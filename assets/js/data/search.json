[
  
  {
    "title": "Oracle DB_NAME、SERVICE_NAME、SID、INSTANCE_NAME、DB_UNIQUE_NAME的区别",
    "url": "/posts/Oracle-DB_NAME-SERVICE_NAME-SID-INSTANCE_NAME-DB_UNIQUE_NAME%E7%9A%84%E5%8C%BA%E5%88%AB/",
    "categories": "DataBase, Oracle",
    "tags": "Oracle",
    "date": "2024-07-19 00:41:47 +0800",
    





    
    "snippet": "DB_NAME：①是数据库名，长度不能超过8个字符，记录在datafile、redolog和control file中②在DataGuard环境中DB_NAME相同而DB_UNIQUE_NAME不同③在RAC环境中，各个节点的DB_NAME 都相同，但是INSTANCE_NAME不同④DB_NAME还在动态注册监听的时候起作用，无论是否定义了SERVICE_NAME,PMON进程都会使用DB...",
    "content": "DB_NAME：①是数据库名，长度不能超过8个字符，记录在datafile、redolog和control file中②在DataGuard环境中DB_NAME相同而DB_UNIQUE_NAME不同③在RAC环境中，各个节点的DB_NAME 都相同，但是INSTANCE_NAME不同④DB_NAME还在动态注册监听的时候起作用，无论是否定义了SERVICE_NAME,PMON进程都会使用DB_NAME动态注册监听DBID：①DBID可以看做是DB_NAME在数据库内部的表示，它是在数据库创建的时候用DB_NAME结合算法计算出来的②它存在于datafile和control file中，用来表示数据文件的归属，所以DBID是唯一的，对于不同的数据库，DB_NAME可以是相同的，但是DBID一定是唯一的，例如在DataGuard中，主备库的DB_NAME相同，但是DBID一定不同（看过一个很形象的例子，就是可以有同名的人，但是身份证号码一定不同）DB_UNIQUE_NAME：①在DataGuard中，主备库拥有相同的DB_NAME，为了区别，就必须有不同的DB_UNIQUE_NAME②DB_UNIQUE_NAME在DG中会影响动态注册的SERVICE_NAME，即如果采用的是动态注册，则注册的SERVICE_NAME为DB_UNIQUE_NAME，但是实例还是INSTANCE_NAME，即SIDINSTANCE_NAME：①数据库实例的名称，INSTANCE_NAME默认值是SID，一般情况下和数据库名称（DB_NAME)相同，也可不同②initSID.ora 和orapwSID 文件要与INSTANCE_NAME保持一致③INSTANCE_NAME会影响进程的名称SID：①是操作系统中的环境变量，和ORACLE_HOME,ORACLE_BASE用法相同②在操作系统中要想得到实例名，就必须使用ORACLE_SID。且ORACLE_SID必须与INSTANCE_NAME的值一致SERVICE_NAME：①数据库和客户端相连是使用的服务名②在DataGuard中，如果采用动态注册，建议在主备库使用相同的service_names③在DataGuard中，如果采用静态注册，建议在主备库上的listener中输入相同的服务名(service_name)④如果采监听采用了静态注册，那么SERVICE_NAME就等于Listener.ora文件中的GLOBAL_DATABASE_NAME的值GLOBAL_DATABASE_NAME：①GLOBAL_DATABASE_NAME 是listener配置的对外网络连接名称，可以是任意值②在客户端配置监听的tnsnames.ora 文件中的service_name与这个GLOBAL_DBNAME 保持一致就可以了③配置静态监听注册时，需要输入SID和GLOBAL_NAME"
  },
  
  {
    "title": "Oracle 修改 db_name",
    "url": "/posts/Oracle-%E4%BF%AE%E6%94%B9-db_name/",
    "categories": "DataBase, Oracle",
    "tags": "Oracle",
    "date": "2024-07-19 00:39:03 +0800",
    





    
    "snippet": "有的时候恢复Oracle数据到另一个环境中之后，需要修改相关的实例名、服务名、数据库名等，方便区分不同的环境。以下操作的前提是数据已经恢复到新的环境，在新的环境中修改db_name。仅修改server_name如果仅修改server_name可以直接登录数据库之后操作；sqlplus sys/sys as sysdba SQL&gt; show parameter service_nameS...",
    "content": "有的时候恢复Oracle数据到另一个环境中之后，需要修改相关的实例名、服务名、数据库名等，方便区分不同的环境。以下操作的前提是数据已经恢复到新的环境，在新的环境中修改db_name。仅修改server_name如果仅修改server_name可以直接登录数据库之后操作；sqlplus sys/sys as sysdba SQL&gt; show parameter service_nameSQL&gt; alter system set service_names='orcl' scope=both;--  修改listener.ora 文件中的服务名：SID_LIST_LISTENER =  (SID_LIST =    (SID_DESC =      (SID_NAME = PLSExtProc)      (ORACLE_HOME = E:\\Oracle10g)      (PROGRAM = extproc)    )   (SID_DESC =    (GLOBAL_DBNAME = ORCL)    (ORACLE_HOME = E:\\Oracle10g)    (SID_NAME = ORCL) ##修改server name    ) )LISTENER =  (DESCRIPTION_LIST =    (DESCRIPTION =      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1))      (ADDRESS = (PROTOCOL = TCP)(HOST = onest)(PORT = 1521))    )  )修改db_name假设已经恢复数据，并且启动了实例，至少处于mount状态，否则无法备份控制文件。此时先不要修改参数文件或者ORACLE_SID信息，不然重启之后会提示错误备份控制文件SQL&gt;  alter database backup controlfile to trace as '/tmp/control.ctl';修改备份的控制文件，备份的控制文件中有两条创建控制文件的提示。根据需求操作， Set #1. NORESETLOGS case 和 Set #2. RESETLOGS case 两个方法因为恢复的数据时候我已经restlogs恢复了，所以此时我只需要重建控制文件即可## 如果需要移动数据文件/表空间目录，可以一并在控制文件重建语句中修改了，vim /tmp/control.ctl-- 如果不需要修改其他参数的话可以直接从spfile启动，不需要单独指定pfile nomount-- STARTUP NOMOUNT--CREATE CONTROLFILE REUSE  修改为 CREATE CONTROLFILE SETCREATE CONTROLFILE SET DATABASE \"db_name\" RESETLOGS  ARCHIVELOG    MAXLOGFILES 16    MAXLOGMEMBERS 3    MAXDATAFILES 100    MAXINSTANCES 8    MAXLOGHISTORY 584LOGFILE  GROUP 1 '/home/u01/app/oracle/oradata/ORACLE_SID/redo01.log'  SIZE 500M BLOCKSIZE 512,  GROUP 2 '/home/u01/app/oracle/oradata/ORACLE_SID/redo02.log'  SIZE 500M BLOCKSIZE 512,  GROUP 3 '/home/u01/app/oracle/oradata/ORACLE_SID/redo03.log'  SIZE 500M BLOCKSIZE 512-- STANDBY LOGFILEDATAFILE  '/home/u01/app/oracle/oradata/ORACLE_SID/system01.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/sysaux01.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/undotbs01.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/users01.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/htxt01.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts01.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmdef521ts01.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmdef521ts02.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmdef521ts03.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmdef521ts04.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmdef521ts05.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts02.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts03.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts04.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/undotbs02.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/undotbs03.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/sysaux02dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts05.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts06.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts07.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts08.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts09.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts10.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts11.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts12.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts13.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts14.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmdef521ts15.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts15.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts16.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts17.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmdef521ts06.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmdef521ts07.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmdef521ts08.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts18.dbf ', -- 需要注意有可能前期运维人员创建数据文件的时候并不规范，或者复制粘贴的时候多了几个空格，不要手抖删了空格  -- 。。。。  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts44.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts45.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts46.dbf',  '/home/u01/app/oracle/oradata/ORACLE_SID/bpmapp521ts47.dbf'CHARACTER SET AL32UTF8;-- RECOVER DATABASE USING BACKUP CONTROLFILE;修改pfile如果需要修改其他参数的话可以此时一并修改了，例如server_name 、 db_name等create pfile='/tmp/pfile.ora' from spfile;修改pfilevim /tmp/pfile.ora## 多个控制文件使用逗号隔开*.control_files='ctl1','ctl2' *.server_name=''*.db_name=''# *.instance_name='' # 实例名不需要修改，和ORACLE_SID的值是一一对应的停止/启动数据库至如果需要修改instance_name，需要在启动之前修改ORACLE_SID, export ORACLE_SID='XXX'shutdown IMMEDIATE-- 如果需要移动数据文件目录/表空间路径，此时停库之后可以移动到新目录，如果需要修改 instance_name，此时可以退出 sqlplus 修改 ORACLE_SID 之后在重新连接 sqlplus-- $ORACLE_HOME/dbs/init$ORACL_SID.ora 使用上文重新修改之后的pfile文件，也可以备份ora文件之后覆盖源ora文件，startup nomount pfile='initxxx.ora';@/tmp/contrl.ctl-- SQL&gt; alter database mount;SQL&gt; show parameter name--  检查文件头SQL&gt; select file#,status,checkpoint_change# from v$datafile_header;set num 20SQL&gt; select distinct checkpoint_change# from v$datafile_header;-- SQL&gt; alter database open ;SQL&gt; alter database open resetlogs;-- 检查日志show parameter diag修改监听如果修改了服务名，记得修改监听文件中的server_name"
  },
  
  {
    "title": "MySQL 批量杀会话",
    "url": "/posts/MySQL-%E6%89%B9%E9%87%8F%E6%9D%80%E4%BC%9A%E8%AF%9D/",
    "categories": "DataBase, MySQL",
    "tags": "MySQL",
    "date": "2024-07-13 00:39:23 +0800",
    





    
    "snippet": "MySQL的kill语法如下：-- 可以查看帮助手册help kill;KILL [CONNECTION | QUERY] processlist_id;KILL CONNECTION 与不带修饰符的 KILL 相同：它在终止连接正在执行的任何语句后终止与给定 processlist_id 关联的连接。会使对应的会话断开连接。KILL QUERY 终止连接当前正在执行的语句，但保持会话连接。...",
    "content": "MySQL的kill语法如下：-- 可以查看帮助手册help kill;KILL [CONNECTION | QUERY] processlist_id;KILL CONNECTION 与不带修饰符的 KILL 相同：它在终止连接正在执行的任何语句后终止与给定 processlist_id 关联的连接。会使对应的会话断开连接。KILL QUERY 终止连接当前正在执行的语句，但保持会话连接。processlist_id 可以通过 show [full] processlist 或者 performance_schema.threads 的 PROCESSLIST_ID 字段获取，也可以根据 information_schema.processlist 的 ID 字段获取。有的时候需要按照用户或者其他条件批量kill session 。可以参考以下语句：SELECT GROUP_CONCAT(CONCAT('KILL ',id,';') SEPARATOR ' ') 'Paste the following query to kill all processes' FROM information_schema.processlist WHERE user&lt;&gt;'system user'\\GSELECT GROUP_CONCAT(CONCAT('KILL ',PROCESSLIST_ID,';') SEPARATOR ' ') 'Paste the following query to kill all processes' FROM performance_schema.threads WHERE PROCESSLIST_USER&lt;&gt;'system user'\\G需要注意的是，kill session 之后，线程可能需要一些时间才能死掉/结束，如果查询show processlist 的 Command 字段状态为 killed ，有可能是因为会话正在回滚。还有的情况是实例存在异常，可以检查 error log，如果 innodb_buffer_pool_size 设置过小，遇到过一次客户安装的时候采用的默认配置，innodb_buffer_pool_size 只有1G左右，整个服务器的内存16G，有点离谱。在 error log 中会提示如下错误2024-07-04T10:35:05.757216+08:00 4736 [Warning] [MY-011959] [InnoDB] Difficult to find free blocks in the buffer pool (192308 search iterations)! 192308 failed attempts to flush a page! Consider increasing the buffer pool size. It is also possible that in your Unix version fsync is very slow, or completely frozen inside the OS kernel. Then upgrading to a newer version of your operating system may help. Look at the number of fsyncs in diagnostic info below. Pending flushes (fsync) log: 0; buffer pool: 0. 31142769 OS file reads, 77384027 OS file writes, 35847289 OS fsyncs. Starting InnoDB Monitor to print further diagnostics to the standard output.将参数值调整之后很快就恢复正常，这里先不介绍该参数重点是怎么批量 kill session ，后续在讨论参数设置。"
  },
  
  {
    "title": "Linux 批量替换文件夹下面的 Windows 换行符替换为 unix 风格换行符",
    "url": "/posts/Linux-%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E9%9D%A2%E7%9A%84Windows%E6%8D%A2%E8%A1%8C%E7%AC%A6%E6%9B%BF%E6%8D%A2%E4%B8%BAunix%E9%A3%8E%E6%A0%BC%E6%8D%A2%E8%A1%8C%E7%AC%A6/",
    "categories": "Linux, Bash",
    "tags": "Shell",
    "date": "2024-07-09 23:26:34 +0800",
    





    
    "snippet": "在Linux系统中，Windows风格的换行符（\\r\\n，即回车加换行）和Unix风格的换行符（\\n）是不同的。Windows系统中的文本文件在Linux中可能会显示为带有^M字符的文件，这是因为^M是回车符（CR，Carriage Return）的表示方式。有的时候将Linux中的文件或者Windows的文件互相拷贝的时候会自动转换换行符，经常遇到的情况是Windows下面可以正常运行一些...",
    "content": "在Linux系统中，Windows风格的换行符（\\r\\n，即回车加换行）和Unix风格的换行符（\\n）是不同的。Windows系统中的文本文件在Linux中可能会显示为带有^M字符的文件，这是因为^M是回车符（CR，Carriage Return）的表示方式。有的时候将Linux中的文件或者Windows的文件互相拷贝的时候会自动转换换行符，经常遇到的情况是Windows下面可以正常运行一些unix风格的脚本，但是Linux中却无法运行Windows dos风格的文件。要将一个文件夹中所有文件的Windows换行符替换为Unix风格的换行符，可以使用find命令结合sed或dos2unix工具来完成。以下是几种方法：  使用find和sed:     find /path/to/folder -type f -exec sed -i 's/\\r$//' {} +        这里/path/to/folder是你的文件夹路径。这个命令会找到该文件夹下所有的文件（不包括子文件夹中的文件），并使用sed命令删除每行末尾的^M字符。    使用find和dos2unix: 如果你的系统中安装了dos2unix工具，可以使用以下命令：     find /path/to/folder -type f -exec dos2unix {} +        dos2unix会将Windows格式的文本文件转换为Unix格式。    使用find和unix2dos: 如果你只有unix2dos工具，可以反向使用它来去除^M：     find /path/to/folder -type f -exec unix2dos -n {} {}.unix2dos \\; &amp;&amp; mv {} {}.unix2dos        这个命令首先创建一个临时文件，然后使用unix2dos将Unix格式转换为Windows格式，这会去掉每行末尾的^M。之后，使用mv命令将临时文件替换原文件。    使用fromdos: 在某些Linux发行版中，fromdos是一个可以用来转换文件的工具：     find /path/to/folder -type f -exec fromdos {} \\;      ***需要注意，使用`sed`的`-i`选项会直接修改原文件，所以在执行之前最好备份你的数据。另外，如果文件夹中包含子文件夹，并且你也希望递归地转换子文件夹中的文件，要修改`find`命令来包括`-depth`参数或相应地调整命令。***如果只有一个文件或者文件少的话也可以直接通过一些文本编辑器自带的转换功能。如果使用vim/gvim的话可以在命令行模式使用以下方法转换：## 查看当前换行符:set ff## 替换为Linux:set ff=unix## 替换为Windows:e +iff=dos"
  },
  
  {
    "title": "配置python jupyter 远程访问",
    "url": "/posts/%E9%85%8D%E7%BD%AEpython-jupyter%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/",
    "categories": "Python, jupyter",
    "tags": "Python",
    "date": "2024-07-02 17:00:00 +0800",
    





    
    "snippet": "概述Jupyter Notebook是一种可共享的文档，它结合了计算机代码、简单语言描述、数据、丰富的可视化效果（如 3D 模型、图表、图形和图形）以及交互式控件。笔记本和编辑器（如 JupyterLab）提供了一个快速的交互环境，用于原型设计和解释代码、探索和可视化数据以及与他人分享想法简而言之，Jupyter Notebook是以网页的形式打开，相当于一个网页版便携式的python 代码...",
    "content": "概述Jupyter Notebook是一种可共享的文档，它结合了计算机代码、简单语言描述、数据、丰富的可视化效果（如 3D 模型、图表、图形和图形）以及交互式控件。笔记本和编辑器（如 JupyterLab）提供了一个快速的交互环境，用于原型设计和解释代码、探索和可视化数据以及与他人分享想法简而言之，Jupyter Notebook是以网页的形式打开，相当于一个网页版便携式的python 代码工具，可以在网页页面中可以直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。配置python虚拟开发环境安装jupyter最好先指定一个虚拟开发环境，避免污染全局的配置。怎么配置python的虚拟开发环境可以参考一文了解virtualenv、pyvenv、pyenv、pyenv virtualenv-腾讯云开发者社区-腾讯云 (tencent.com)┌─[✗]─[wxj@devC]─[/data/Python]└──╼ $ python3 -VPython 3.11.2┌─[wxj@devC]─[/data/Python]└──╼ $ python3 -m venv pyenv┌─[wxj@devC]─[/data/Python]└──╼ $┌─[wxj@devC]─[/data/Python]└──╼ $ source pyenv/bin/activate ## pyenv/bin/activate 实际就是一个文本文件，可以直接查看执行逻辑(pyenv) ┌─[wxj@devC]─[/data/Python] ## 这里(pyenv)就表示当前的开发环境是刚才创建的虚拟开发环境└──╼ $## 配置好之后可以直接查看当前的python信息(pyenv) ┌─[wxj@devC]─[/data/Python]└──╼ $ python -VPython 3.11.2(pyenv) ┌─[wxj@devC]─[/data/Python]└──╼ $ pip -Vpip 23.0.1 from /data/Python/pyenv/lib/python3.11/site-packages/pip (python 3.11)(pyenv) ┌─[wxj@devC]─[/data/Python]└──╼ $ pip listPackage    Version---------- -------pip        23.0.1setuptools 66.1.1(pyenv) ┌─[wxj@devC]─[/data/Python]└──╼ $安装 jupyter notebook## pip install jupyter## 指定下载源为清华源pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jupyterpip list## 安装完成之后可以查看帮助说明，大概了解使用命令jupyter notebook --help使用 jupyter notebook启动启动 jupyter notebook就比较简单了，可以直接不带任何参数启动。默认是127.0.0.1:8888，如果8888端口被占用，会使用其他端口，例如8889。使用本地浏览器打开对应的地址即可。jupyter notebook## 如果使用root用户启动的话，需要添加参数 --allow-rootjupyter notebook --allow-root停止直接使用crtl+c就可以退出。这里需要输入‘y’才会退出，如果超过5s没有输入，则会继续运行。终端关闭或者终止jupyter进程，jupyter notebook也就退出了，无法继续使用浏览器访问。可以使用nohup的方式后台运行程序：nohup jupyter notebook &amp;&gt; notebook.log &amp;也可以使用screen等工具在后台运行，防止终端异常断开之后无法继续使用。很多时候程序都是部署在远程的，需要通过连接的方式访问，jupyter notebook 默认是通过本地访问的。配置远程访问jupyter设置密码先输入python3进入交互模式，输入密码，需要注意的是交互输入的原文密码在终端是不会显示的。如果不想交互输入密码也可以直接将密码写在函数中：passwd('passwd')如果想指定加密方式为sha1：passwd('passwd',algorithm='sha1')生成配置文件在终端输入执行以下命令：jupyter notebook --generate-config执行成功就会自动在根目录下生成文件（~/.jupyter/jupyter_notebook_config.py）,这里可以用vim或者其他文本编辑器编辑就行。这个文件的内容默认都是注释掉的。除了红框中的这一行。修改配置文件可以直接在文件末尾添加自己的配置参数，保险起见可以先备份一份原始文件。## 这里的{,.bak}表示逗号前的内容都相同，\".bak\"表示后缀/多余的字符，在操作文件名很长的时候可以节约tab或者手写的频率，相当于## cp ~/.jupyter/jupyter_notebook_config.py  ~/.jupyter/jupyter_notebook_config.py.bakcp ~/.jupyter/jupyter_notebook_config.py{,.bak}## 添加以下内容c.NotebookApp.ip='*' # 如果这里修过过后启动服务报错 则修改为c.NotebookApp.ip='0.0.0.0'c.NotebookApp.password=u'argon2:$argon2id$v=19$m=10240,t=10,p=8$YPy6gq6WBGap+NHlZAMZow$IR1WDR20vmzV+MzuRkwl3NRYH1AoKsIZjYKsdclJM' #就之前保存的验证密码c.NotebookApp.open_browser =False # 设置是否自动打开浏览器，如果是远程的服务器可以关闭这个选项c.NotebookApp.port =4000  # 设置监听端口c.NotebookApp.allow_remote_access = True ## 允许远程访问c.NotebookApp.notebook_dir='work_dir' # 设置工作/根路径，如果不设置默认是启动jupyter命令时的目录保存退出之后运行jupyter即可。远程访问jupyternohup jupyter notebook &amp;&gt; notebook.log &amp;启动以后在本机的浏览器 输入http://{服务器ip}:port 进行访问。如果远程服务器或者云服务器配置了防火墙，记得打开白名单。打开之后输入之前设置的密码即可。之后就可以在浏览器中利用jupyter运行调试代码了。"
  },
  
  {
    "title": "配置pip镜像源",
    "url": "/posts/%E9%85%8D%E7%BD%AEpip%E9%95%9C%E5%83%8F%E6%BA%90/",
    "categories": "Python, pip",
    "tags": "Python",
    "date": "2024-07-01 17:00:00 +0800",
    





    
    "snippet": "很多时候pip下载安装包的时候都比较慢，可以直接指定为国内的镜像源，提高下载速度。## 查看当前的镜像源pip config list ## 国外镜像有时候下载较慢，可以直接指定国内镜像源下载pip install -i https://pypi.douban.com/simple/ flask## 修改pip的配置文件，将镜像源写入配置文件中。如果没有这个文件就新建一个cat ~/.pip...",
    "content": "很多时候pip下载安装包的时候都比较慢，可以直接指定为国内的镜像源，提高下载速度。## 查看当前的镜像源pip config list ## 国外镜像有时候下载较慢，可以直接指定国内镜像源下载pip install -i https://pypi.douban.com/simple/ flask## 修改pip的配置文件，将镜像源写入配置文件中。如果没有这个文件就新建一个cat ~/.pip/pip.conf[global]index-url = https://pypi.douban.com/simple/## 清华大学源cat ~/.pip/pip.conf[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn"
  },
  
  {
    "title": "WSL Fedora 升级",
    "url": "/posts/WSL-Fedora-%E5%8D%87%E7%BA%A7/",
    "categories": "Linux, Fedora",
    "tags": "WSL",
    "date": "2024-06-27 16:00:00 +0800",
    





    
    "snippet": "Windows11 WSL Fedora 版本升级可以直接使用dnf update，使用如下命令：sudo dnf update --releasever=40 -y    本次升级基于Fedora 39版本，如需要升级到其它版本，将上述命令的–releasever变更为其它版本即可。等待更新完成之后检查。",
    "content": "Windows11 WSL Fedora 版本升级可以直接使用dnf update，使用如下命令：sudo dnf update --releasever=40 -y    本次升级基于Fedora 39版本，如需要升级到其它版本，将上述命令的–releasever变更为其它版本即可。等待更新完成之后检查。"
  },
  
  {
    "title": "vim 安装",
    "url": "/posts/vim-%E5%AE%89%E8%A3%85/",
    "categories": "vim",
    "tags": "vim",
    "date": "2024-06-25 16:00:00 +0800",
    





    
    "snippet": "写在前面因为我大部分的运维工作都是在Linux环境中进行的，而且都是命令行操作，为了更加便捷所以决定好好的学习一下vim编辑器。几年前刚接触vi/vim的时候，确实如网上说的那样不知道怎么退出这个神秘的编辑器。又不像图像化界面那样右上角有一个关闭按钮，crtl+c居然也不行，最终靠百度才退出这个难用的编辑器。后来随着工作的原因接触vim的时间也就多了起来。知道怎么退出这个编辑器，除了是在没办...",
    "content": "写在前面因为我大部分的运维工作都是在Linux环境中进行的，而且都是命令行操作，为了更加便捷所以决定好好的学习一下vim编辑器。几年前刚接触vi/vim的时候，确实如网上说的那样不知道怎么退出这个神秘的编辑器。又不像图像化界面那样右上角有一个关闭按钮，crtl+c居然也不行，最终靠百度才退出这个难用的编辑器。后来随着工作的原因接触vim的时间也就多了起来。知道怎么退出这个编辑器，除了是在没办法还是不想用这个玩意儿的。无法像Windows使用crtl+c和crtl+v复制粘贴，编辑器起来真是痛苦，很多时候都是把文件从服务器上传送到本地之后修改，在传送到服务器上。或者在命令行使用管道符和cat的方式将一大段文本写入到文件中。后来慢慢的喜欢上了这个编辑器，编辑文本的效率真的快。还有一个原因是作为IT从业者，很多时候都在座位上坐着，右手长时间使用鼠标导致手臂和食指有点难受，确定尝试一段时间vim。虽然一开始很痛苦，也看了网上关于vim的看法，以及nvim和emacs的对比，不过考虑到Linux环境中一般都安装有vim，为了习惯运维环境，最后还是确定选择vim。使用了一段时间之后右手确实舒服了很多。本人也喜欢折腾各种环境，前段时间利用github pages搭建了一个个人站点，所以也准备将vim的学习和使用通过博客记录下来。安装通过软件仓库安装## Linux系列sudo dnf install -y vim## debiansudo apt install -y vim通过源码编译安装安装依赖## aptapt install -y libncurses-devapt install -y python3-dev## dnfdnf install -y python3-develdnf install -y ncurses-devel获取源码cd ~git clone https://github.com/vim/vim.git编译安装cd vimmake distclean ## 如果之前编译过使用此命令清除缓存## python3-config --configdir 就是操作系统自带的 python3 的 config 目录，/usr/lib/python3.7/config-3.7m-x86_64-linux-gnu ，如果没有这个命令就直接写路径./configure --with-features=huge \\            --enable-multibyte \\            --enable-rubyinterp=yes \\            --enable-python3interp=yes \\            --with-python3-config-dir=$(python3-config --configdir) \\            --enable-luainterp=yes \\            --enable-gui=gtk2 \\            --enable-cscope \\            --prefix=/usr/local/make VIMRUNTIMEDIR=/usr/local/share/vim/vim91cd ~/vimsudo make installvim --version安装gvim如果准备在Windows或者带有桌面的Linux环境中使用vim的话，还是建议把gvim也安装了。Windows直接在download : vim online下载对应的安装包安装即可。Redhat系列sudo dnf install -y vim-X11debain系列sudo apt install -y vim-gui-common设置vim为默认输入法设置环境变量的方式vim ~/.bashrcexport EDITOR=vim通过vim-default长期使用vim之后，不习惯nano，所以直接卸载了nano## 如果后续还需要使用nano的话 可以省略卸载nano rpm -qa | grep -i nanosudo dnf remove nano### 或者直接安装vim-default，先卸载nano-defaultsudo dnf remove nano-default-editor -ysudo dnf install vim-default-editor -y总结vim在编辑文件这一方面个人觉得还是效率还是很高的。我也不需要开发大型的项目，所以使用日常使用vim感觉能提高不少效率。我也会使用vscode和vstudio，在编写python的时候也会使用pycharm，通过这些ide可以让我更加方便编写对应的开发语言。所以ide和vim我都会搭配使用。"
  },
  
  {
    "title": "查看磁盘是SSD还是HDD",
    "url": "/posts/Linux-%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E6%98%AFSSD%E8%BF%98%E6%98%AFHDD/",
    "categories": "Linux, Tutorial",
    "tags": "Linux",
    "date": "2024-02-27 00:34:00 +0800",
    





    
    "snippet": "lsscsi通过lsscsi命令查看。lsscsi命令来自英文词组“List SCSI”的缩写，其功能是用于列出SCSI设备及属性信息，SCSI全称为small computer system interface，是一种常用的小型计算机系统接口。lsscsi命令可以很方便地帮助管理员区分哪些是固态硬盘、哪些是SATA盘、哪些是FC盘。不过在我的腾讯云服务器和旧的笔记本上都没有获取到对应的信息...",
    "content": "lsscsi通过lsscsi命令查看。lsscsi命令来自英文词组“List SCSI”的缩写，其功能是用于列出SCSI设备及属性信息，SCSI全称为small computer system interface，是一种常用的小型计算机系统接口。lsscsi命令可以很方便地帮助管理员区分哪些是固态硬盘、哪些是SATA盘、哪些是FC盘。不过在我的腾讯云服务器和旧的笔记本上都没有获取到对应的信息。如果你也无法通过lsscsi获取到磁盘类型的话，可以通过下文lsblk命令获取。lsscsi命令英文手册https://sg.danny.cz/scsi/lsscsi.htmllsscsi 命令语法：lsscsi [选项] [H:C:T:L]lsscsi 命令选项：            选项      含义                  -g      显示SCSI通用设备文件名称              -k      显示内核名称而不是设备节点名              -d      显示设备节点的主要号码和次要号码              -H      列出当前连接到系统的SCSI主机而不是SCSI设备              -l      显示每一个SCSI设备（主机）的附加信息              -c      相对于执行 cat /proc/scsi/scsi 命令的输出              -p      显示额外的数据完整性（保护）的信息              -t      显示传输信息              -L      以“属性名=值”的方式显示附加信息              -v      当信息找到时输出目录名              -y      假设sysfs挂载在指定路径而不是默认的 “/sys”              -s      显示容量大小。              -c      用全称显示默认的信息。              -d      显示设备主，次设备号。              -g      显示对应的sg设备名。              -H      显示主机控制器列表，-Hl,-Hlv。              -l      显示相关属性，-ll,-lll=-L。              -v      显示设备属性所在目录。              -x      以16进制显示lun号。              -p      输出DIF,DIX 保护类型。              -P      输出有效的保护模式信息。              -i      显示udev相关的属性              -w      显示WWN              -t      显示相应传输信息(ATA,FC,SBP,ISCSI,SPI,SAS,SATA,USB)，-Ht,-tl.（包括sas地址）      如果系统没有的话可以直接dnf或者apt安装。#Debianapt-get install lsscsi #Ubuntuapt-get install lsscsi #Alpineapk add lsscsi #Arch Linuxpacman -S lsscsi #Kali Linuxapt-get install lsscsi #CentOSyum install lsscsi #Fedoradnf install lsscsi #Raspbianapt-get install lsscsi #Dockerdocker run cmd.cat/lsscsi lsscsi我的腾讯云服务器，通过lsscsi查看，可以发现是QEMU。## 如果系统没有的话可以直接dnf或者apt安装┌─[root@DarkStarDevC]─[~]└──╼ # dnf install -y lsscsi┌─[root@DarkStarDevC]─[~]└──╼ # lsscsi[0:0:1:0]    cd/dvd  QEMU     QEMU DVD-ROM     2.5+  /dev/sr0腾讯云轻量服务器的信息磁盘信息如下：┌─[root@devC]─[~]└──╼ # lsscsi[0:0:1:0]    cd/dvd  QEMU     QEMU DVD-ROM     2.5+  /dev/sr0大学时期买的笔记本可以查看到的信息如下：wxj@wxj-PC:~$ sudo apt install -y lsscsiwxj@wxj-PC:~$ lsscsi[0:0:0:0]    disk    ATA      KINGSTON SHFS37A BBF0  /dev/sda[2:0:0:0]    disk    ATA      ST500LT012-1DG14 LVM1  /dev/sdblsblklsblk命令的英文是“list block”，即用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。块设备有硬盘，闪存盘，CD-ROM等等。lsblk命令包含util-linux中。通过yum provides lsblk命令查看命令对应的软件包。-d 输出设备名称-o 仅显示特定的列如果rota列的值是1 证明是可以旋转，就是HDD，反之数值是0是SSDwxj@wxj-PC:~$ lsblk  -d -o name,rotaNAME    ROTAsda    0sdb    1┌─[root@DarkStarDevC]─[~]└──╼ # lsblk  -d -o name,rotaNAME  ROTAsr0      1zram0    0vda      1vdb      1获取帮助信息┌─[root@DarkStarDevC]─[~]└──╼ # lsblk --helpUsage: lsblk [options] [&lt;device&gt; ...]List information about block devices.Options: -A, --noempty        don't print empty devices -D, --discard        print discard capabilities -E, --dedup &lt;column&gt; de-duplicate output by &lt;column&gt; -I, --include &lt;list&gt; show only devices with specified major numbers -J, --json           use JSON output format -M, --merge          group parents of sub-trees (usable for RAIDs, Multi-path) -O, --output-all     output all columns -P, --pairs          use key=\"value\" output format -S, --scsi           output info about SCSI devices -N, --nvme           output info about NVMe devices -v, --virtio         output info about virtio devices -T, --tree[=&lt;column&gt;] use tree format output -a, --all            print all devices -b, --bytes          print SIZE in bytes rather than in human readable format -d, --nodeps         don't print slaves or holders -e, --exclude &lt;list&gt; exclude devices by major number (default: RAM disks) -f, --fs             output info about filesystems -i, --ascii          use ascii characters only -l, --list           use list format output -m, --perms          output info about permissions -n, --noheadings     don't print headings -o, --output &lt;list&gt;  output columns -p, --paths          print complete device path -r, --raw            use raw output format -s, --inverse        inverse dependencies -t, --topology       output info about topology -w, --width &lt;num&gt;    specifies output width as number of characters -x, --sort &lt;column&gt;  sort output by &lt;column&gt; -y, --shell          use column names to be usable as shell variable identifiers -z, --zoned          print zone related information     --sysroot &lt;dir&gt;  use specified directory as system root -h, --help           display this help -V, --version        display versionAvailable output columns:    ALIGNMENT  alignment offset      ID-LINK  the shortest udev /dev/disk/by-id link name           ID  udev ID (based on ID-LINK)     DISC-ALN  discard alignment offset          DAX  dax-capable device    DISC-GRAN  discard granularity     DISK-SEQ  disk sequence number     DISC-MAX  discard max bytes    DISC-ZERO  discard zeroes data      FSAVAIL  filesystem size available      FSROOTS  mounted filesystem roots       FSSIZE  filesystem size       FSTYPE  filesystem type       FSUSED  filesystem size used       FSUSE%  filesystem use percentage        FSVER  filesystem version        GROUP  group name         HCTL  Host:Channel:Target:Lun for SCSI      HOTPLUG  removable or hotplug device (usb, pcmcia, ...)        KNAME  internal kernel device name        LABEL  filesystem LABEL      LOG-SEC  logical sector size      MAJ:MIN  major:minor device number       MIN-IO  minimum I/O size         MODE  device node permissions        MODEL  device identifier           MQ  device queues         NAME  device name       OPT-IO  optimal I/O size        OWNER  user name    PARTFLAGS  partition flags    PARTLABEL  partition LABEL        PARTN  partition number as read from the partition table     PARTTYPE  partition type code or UUID PARTTYPENAME  partition type name     PARTUUID  partition UUID         PATH  path to the device node      PHY-SEC  physical sector size       PKNAME  internal parent kernel device name       PTTYPE  partition table type       PTUUID  partition table identifier (usually UUID)           RA  read-ahead of the device         RAND  adds randomness          REV  device revision           RM  removable device           RO  read-only device         ROTA  rotational device      RQ-SIZE  request queue size        SCHED  I/O scheduler name       SERIAL  disk serial number         SIZE  size of the device        START  partition start offset        STATE  state of the device   SUBSYSTEMS  de-duplicated chain of subsystems   MOUNTPOINT  where the device is mounted  MOUNTPOINTS  all locations where device is mounted         TRAN  device transport type         TYPE  device type         UUID  filesystem UUID       VENDOR  device vendor        WSAME  write same max bytes          WWN  unique storage identifier        ZONED  zone model      ZONE-SZ  zone size   ZONE-WGRAN  zone write granularity     ZONE-APP  zone append max bytes      ZONE-NR  number of zones    ZONE-OMAX  maximum number of open zones    ZONE-AMAX  maximum number of active zonesFor more details see lsblk(8)."
  }
  
]

