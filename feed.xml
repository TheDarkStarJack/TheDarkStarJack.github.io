

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://thedarkstarjack.github.io/</id>
  <title>DarkStar</title>
  <subtitle>Blog and portfolio focused on Linux, Database, Shell, Python, CPP, and other technical things.</subtitle>
  <updated>2024-09-10T17:41:17+08:00</updated>
  <author>
    <name>TheDarkStarJack</name>
    <uri>https://thedarkstarjack.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://thedarkstarjack.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="zh-CN"
    href="https://thedarkstarjack.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator>
  <rights> © 2024 TheDarkStarJack </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Linux 函数说明</title>
    <link href="https://thedarkstarjack.github.io/posts/Linux-%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/" rel="alternate" type="text/html" title="Linux 函数说明" />
    <published>2024-09-10T13:52:25+08:00</published>
  
    <updated>2024-09-10T13:52:25+08:00</updated>
  
    <id>https://thedarkstarjack.github.io/posts/Linux-%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/</id>
    <content src="https://thedarkstarjack.github.io/posts/Linux-%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/" />
    <author>
      <name>TheDarkStarJack</name>
    </author>

  
    
    <category term="Linux" />
    
    <category term="man" />
    
  

  <summary>前言

在 strace 进程的时候会显示出来调用的函数，有的时候查看数据库进程的时候方便查看，在这里记录一下一些函数的说明

函数

以下内容结合 chatgpt 和 google 翻译

truncate

描述
truncate, ftruncate 函数作用是将文件截断为指定长度，函数原型

定义
#include &amp;amp;lt;unistd.h&amp;amp;gt;
#include &amp;amp;lt;sys/types.h&amp;amp;gt;

int truncate(const char *path, off_t length);
int ftruncate(int fd, off_t length);


truncate() 和 ftruncate() 函数导致由路径命名或由 fd 引用的常规文件被截断为精确长度字节的大小。

如果文件以前大于此大小，则多余的数据将丢失。如果文件以前较短，则会对其进行扩展...</summary>

  </entry>

  
  <entry>
    <title>PostgreSQL OID</title>
    <link href="https://thedarkstarjack.github.io/posts/PostgreSQL-OID/" rel="alternate" type="text/html" title="PostgreSQL OID" />
    <published>2024-09-10T11:47:22+08:00</published>
  
    <updated>2024-09-10T11:47:22+08:00</updated>
  
    <id>https://thedarkstarjack.github.io/posts/PostgreSQL-OID/</id>
    <content src="https://thedarkstarjack.github.io/posts/PostgreSQL-OID/" />
    <author>
      <name>TheDarkStarJack</name>
    </author>

  
    
    <category term="DataBase" />
    
    <category term="PostgreSQL" />
    
  

  <summary>前言

在 PostgreSQL 内部，所有的数据库对象都通过相应的对象标识符（Object Identifiers, OID）进行管理，这些标识符是无符号的 4 字节整型。数据库对象与相应 OID 之间的关系存储在相应的系统目录中，依具体的对象类型而异。 例如数据库和堆表对象的 OID 分别存储在 pg_database 和 pg_class 中，如果需要获取 OID 时，可以执行以下查询：

SELECT datname, oid FROM pg_database WHERE datname = &amp;#39;&amp;amp;amp;dbname&amp;#39;;

SELECT relname, oid FROM pg_class WHERE relname = &amp;#39;&amp;amp;amp;relname&amp;#39;;

SELECT pg_relation_filepath(&amp;#39;&amp;amp;amp;tabname&amp;#39;);


注意

rename tab...</summary>

  </entry>

  
  <entry>
    <title>PostgreSQL 硬性限制</title>
    <link href="https://thedarkstarjack.github.io/posts/PostgreSQL-%E7%A1%AC%E6%80%A7%E9%99%90%E5%88%B6/" rel="alternate" type="text/html" title="PostgreSQL 硬性限制" />
    <published>2024-09-06T15:43:17+08:00</published>
  
    <updated>2024-09-06T15:43:17+08:00</updated>
  
    <id>https://thedarkstarjack.github.io/posts/PostgreSQL-%E7%A1%AC%E6%80%A7%E9%99%90%E5%88%B6/</id>
    <content src="https://thedarkstarjack.github.io/posts/PostgreSQL-%E7%A1%AC%E6%80%A7%E9%99%90%E5%88%B6/" />
    <author>
      <name>TheDarkStarJack</name>
    </author>

  
    
    <category term="DataBase" />
    
    <category term="PostgreSQL" />
    
  

  <summary>https://www.postgresql.org/docs/current/limits.html

在使用 pg 的时候，需要注意一些硬性限制，例如代码中写死的，这里记录一下，方便自己查阅，有的时候直接查阅官网反而因为内容太多导致忘记这些关键内容


  
    
      Item
      Upper Limit
      Comment
    
  
  
    
      database size
      unlimited
       
    
    
      number of databases
      4,294,950,911
       
    
    
      relations per database
      1,431,650,303
       
    
    
      relation s...</summary>

  </entry>

  
  <entry>
    <title>Linux 利用 wc 统计行数和字符长度</title>
    <link href="https://thedarkstarjack.github.io/posts/Linux-%E5%88%A9%E7%94%A8-wc-%E7%BB%9F%E8%AE%A1%E8%A1%8C%E6%95%B0%E5%92%8C%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6/" rel="alternate" type="text/html" title="Linux 利用 wc 统计行数和字符长度" />
    <published>2024-09-05T16:18:22+08:00</published>
  
    <updated>2024-09-05T16:18:22+08:00</updated>
  
    <id>https://thedarkstarjack.github.io/posts/Linux-%E5%88%A9%E7%94%A8-wc-%E7%BB%9F%E8%AE%A1%E8%A1%8C%E6%95%B0%E5%92%8C%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6/</id>
    <content src="https://thedarkstarjack.github.io/posts/Linux-%E5%88%A9%E7%94%A8-wc-%E7%BB%9F%E8%AE%A1%E8%A1%8C%E6%95%B0%E5%92%8C%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6/" />
    <author>
      <name>TheDarkStarJack</name>
    </author>

  
    
    <category term="Linux" />
    
    <category term="tools" />
    
  

  <summary>前言

在 Linux 环境中可以利用 wc 工具统计行数和字符长度等

统计行数和字符长度

wc 使用特别简单，可以使用 wc --help 查看使用帮助，本文主要记录一下统计行数和字符长度的时候遇到的一个小问题，统计字符的长度不准

在统计一个字符长度的时候明明是 24 位，但是 wc 的结果却是 25
┌─[postgres@darkstarc]─[/Postgres/tools]
└──╼ $ echo 000000010000000000000001 | wc -m
25

还好我记得长度是 24 ，wc 统计的结果却是 25，多出来一个字符长度，这是什么原因呢？
┌─[postgres@darkstarc]─[/Postgres/tools]
└──╼ $ echo 1 | wc -m
2
┌─[postgres@darkstarc]─[/Postgres/tools]...</summary>

  </entry>

  
  <entry>
    <title>PostgreSQL Write Ahead Logging WAL</title>
    <link href="https://thedarkstarjack.github.io/posts/PostgreSQL-Write-Ahead-Logging-WAL/" rel="alternate" type="text/html" title="PostgreSQL Write Ahead Logging WAL" />
    <published>2024-09-05T15:15:35+08:00</published>
  
    <updated>2024-09-05T15:15:35+08:00</updated>
  
    <id>https://thedarkstarjack.github.io/posts/PostgreSQL-Write-Ahead-Logging-WAL/</id>
    <content src="https://thedarkstarjack.github.io/posts/PostgreSQL-Write-Ahead-Logging-WAL/" />
    <author>
      <name>TheDarkStarJack</name>
    </author>

  
    
    <category term="DataBase" />
    
    <category term="PostgreSQL" />
    
  

  <summary>前言

WAL 是 Write Ahead Log 的缩写，预写式日志。WAL log 也被称为 xlog 。WalWriter 进程就是写 WAL 日志的进程。预写式日志的概念就是在修改数据之前，必须要把这些修改操作记录到磁盘中，这样后面更新实际数据时，就不需要实时地把数据持久化到文件中了。即使机器突然宕机或数据库异常退出，导致一部分内存中的脏数据没有及时地刷新到文件中，在数据库重启后，通过读取 WAL 日志，并把最后一部分的 WAL 日志重新执行一遍，就可以恢复到宕机时的状态。

作用

WAL 可以理解为 pg 数据库的重做日志与 Oracle 的Redo Log 的功能是一样的。

因为 WAL 的存在，所以日志类型的文件系统对于 pg 来说不是必须的。例如 zfs 就是日志类型的文件系统，在持久化之前会记录日志，保证数据的原子性。（而且每当新数据写入 ZFS 时，它都会为该...</summary>

  </entry>

</feed>


